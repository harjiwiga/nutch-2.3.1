<html>
<body>
<table border="1">
<tr>
<td>name</td><td>value</td><td>description</td>
</tr>
<tr>
<td><a name="store.ip.address">store.ip.address</a></td><td>false</td><td>Enables us to capture the specific IP address 
  (InetSocketAddress) of the host which we connect to via 
  the given protocol.
  </td>
</tr>
<tr>
<td><a name="file.content.limit">file.content.limit</a></td><td>-1</td><td>The length limit for downloaded content using the file
   protocol, in bytes. If this value is nonnegative (&gt;=0), content longer
   than it will be truncated; otherwise, no truncation at all. Do not
   confuse this setting with the http.content.limit setting.
  </td>
</tr>
<tr>
<td><a name="file.crawl.redirect_noncanonical">file.crawl.redirect_noncanonical</a></td><td>true</td><td>
    If true, protocol-file treats non-canonical file names as
    redirects and does not canonicalize file names internally. A file
    name containing symbolic links as path elements is then not
    resolved and "fetched" but recorded as redirect with the
    canonical name (all links on path are resolved) as redirect
    target.
  </td>
</tr>
<tr>
<td><a name="file.content.ignored">file.content.ignored</a></td><td>true</td><td>If true, no file content will be saved during fetch.
  And it is probably what we want to set most of time, since file:// URLs
  are meant to be local and we can always use them directly at parsing
  and indexing stages. Otherwise file contents will be saved.
  !! NO IMPLEMENTED YET !!
  </td>
</tr>
<tr>
<td><a name="file.crawl.parent">file.crawl.parent</a></td><td>false</td><td>The crawler is not restricted to the directories that you specified in the
    urls file but it is jumping into the parent directories as well. For your own crawling you can
    change this behavior (set to false) the way that only directories beneath the directories that you specify get
    crawled.
  </td>
</tr>
<tr>
<td><a name="http.agent.name">http.agent.name</a></td><td></td><td>HTTP 'User-Agent' request header. MUST NOT be empty - 
  please set this to a single word uniquely related to your organization.

  NOTE: You should also check other related properties:

	http.robots.agents
	http.agent.description
	http.agent.url
	http.agent.email
	http.agent.version

  and set their values appropriately.

  </td>
</tr>
<tr>
<td><a name="http.robots.agents">http.robots.agents</a></td><td></td><td>Any other agents, apart from 'http.agent.name', that the robots
  parser would look for in robots.txt. Multiple agents can be provided using 
  comma as a delimiter. eg. mybot,foo-spider,bar-crawler
  
  The ordering of agents does NOT matter and the robots parser would make 
  decision based on the agent which matches first to the robots rules.  
  Also, there is NO need to add a wildcard (ie. "*") to this string as the 
  robots parser would smartly take care of a no-match situation. 
    
  If no value is specified, by default HTTP agent (ie. 'http.agent.name') 
  would be used for user agent matching by the robots parser. 
  </td>
</tr>
<tr>
<td><a name="http.robots.403.allow">http.robots.403.allow</a></td><td>true</td><td>Some servers return HTTP status 403 (Forbidden) if
  /robots.txt doesn't exist. This should probably mean that we are
  allowed to crawl the site nonetheless. If this is set to false,
  then such sites will be treated as forbidden.</td>
</tr>
<tr>
<td><a name="http.agent.description">http.agent.description</a></td><td></td><td>Further description of our bot- this text is used in
  the User-Agent header.  It appears in parenthesis after the agent name.
  </td>
</tr>
<tr>
<td><a name="http.agent.url">http.agent.url</a></td><td></td><td>A URL to advertise in the User-Agent header.  This will 
   appear in parenthesis after the agent name. Custom dictates that this
   should be a URL of a page explaining the purpose and behavior of this
   crawler.
  </td>
</tr>
<tr>
<td><a name="http.agent.email">http.agent.email</a></td><td></td><td>An email address to advertise in the HTTP 'From' request
   header and User-Agent header. A good practice is to mangle this
   address (e.g. 'info at example dot com') to avoid spamming.
  </td>
</tr>
<tr>
<td><a name="http.agent.version">http.agent.version</a></td><td>Nutch-2.3-SNAPSHOT</td><td>A version string to advertise in the User-Agent 
   header.</td>
</tr>
<tr>
<td><a name="http.agent.host">http.agent.host</a></td><td></td><td>Name or IP address of the host on which the Nutch crawler
  would be running. Currently this is used by 'protocol-httpclient'
  plugin.
  </td>
</tr>
<tr>
<td><a name="http.timeout">http.timeout</a></td><td>10000</td><td>The default network timeout, in milliseconds.</td>
</tr>
<tr>
<td><a name="http.max.delays">http.max.delays</a></td><td>100</td><td>The number of times a thread will delay when trying to
  fetch a page.  Each time it finds that a host is busy, it will wait
  fetcher.server.delay.  After http.max.delays attepts, it will give
  up on the page for now.</td>
</tr>
<tr>
<td><a name="http.content.limit">http.content.limit</a></td><td>-1</td><td>The length limit for downloaded content using the http
  protocol, in bytes. If this value is nonnegative (&gt;=0), content longer
  than it will be truncated; otherwise, no truncation at all. Do not
  confuse this setting with the file.content.limit setting.
  </td>
</tr>
<tr>
<td><a name="http.proxy.host">http.proxy.host</a></td><td></td><td>The proxy hostname.  If empty, no proxy is used.</td>
</tr>
<tr>
<td><a name="http.proxy.port">http.proxy.port</a></td><td></td><td>The proxy port.</td>
</tr>
<tr>
<td><a name="http.proxy.username">http.proxy.username</a></td><td></td><td>Username for proxy. This will be used by
  'protocol-httpclient', if the proxy server requests basic, digest
  and/or NTLM authentication. To use this, 'protocol-httpclient' must
  be present in the value of 'plugin.includes' property.
  NOTE: For NTLM authentication, do not prefix the username with the
  domain, i.e. 'susam' is correct whereas 'DOMAIN\susam' is incorrect.
  </td>
</tr>
<tr>
<td><a name="http.proxy.password">http.proxy.password</a></td><td></td><td>Password for proxy. This will be used by
  'protocol-httpclient', if the proxy server requests basic, digest
  and/or NTLM authentication. To use this, 'protocol-httpclient' must
  be present in the value of 'plugin.includes' property.
  </td>
</tr>
<tr>
<td><a name="http.proxy.realm">http.proxy.realm</a></td><td></td><td>Authentication realm for proxy. Do not define a value
  if realm is not required or authentication should take place for any
  realm. NTLM does not use the notion of realms. Specify the domain name
  of NTLM authentication as the value for this property. To use this,
  'protocol-httpclient' must be present in the value of
  'plugin.includes' property.
  </td>
</tr>
<tr>
<td><a name="http.auth.file">http.auth.file</a></td><td>httpclient-auth.xml</td><td>Authentication configuration file for
  'protocol-httpclient' plugin.
  </td>
</tr>
<tr>
<td><a name="http.verbose">http.verbose</a></td><td>false</td><td>If true, HTTP will log more verbosely.</td>
</tr>
<tr>
<td><a name="http.useHttp11">http.useHttp11</a></td><td>false</td><td>NOTE: at the moment this works only for protocol-httpclient.
  If true, use HTTP 1.1, if false use HTTP 1.0 .
  </td>
</tr>
<tr>
<td><a name="http.accept.language">http.accept.language</a></td><td>en-us,en-gb,en;q=0.7,*;q=0.3</td><td>Value of the "Accept-Language" request header field.
  This allows selecting non-English language as default one to retrieve.
  It is a useful setting for search engines build for certain national group.
  </td>
</tr>
<tr>
<td><a name="http.accept">http.accept</a></td><td>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</td><td>Value of the "Accept" request header field.
  </td>
</tr>
<tr>
<td><a name="http.store.responsetime">http.store.responsetime</a></td><td>true</td><td>Enables us to record the response time of the 
  host which is the time period between start connection to end 
  connection of a pages host.</td>
</tr>
<tr>
<td><a name="ftp.username">ftp.username</a></td><td>anonymous</td><td>ftp login username.</td>
</tr>
<tr>
<td><a name="ftp.password">ftp.password</a></td><td>anonymous@example.com</td><td>ftp login password.</td>
</tr>
<tr>
<td><a name="ftp.content.limit">ftp.content.limit</a></td><td>65536</td><td>The length limit for downloaded content, in bytes.
  If this value is nonnegative (&gt;=0), content longer than it will be truncated;
  otherwise, no truncation at all.
  Caution: classical ftp RFCs never defines partial transfer and, in fact,
  some ftp servers out there do not handle client side forced close-down very
  well. Our implementation tries its best to handle such situations smoothly.
  </td>
</tr>
<tr>
<td><a name="ftp.timeout">ftp.timeout</a></td><td>150000</td><td>Default timeout for ftp client socket, in millisec.
  Please also see ftp.keep.connection below.</td>
</tr>
<tr>
<td><a name="ftp.server.timeout">ftp.server.timeout</a></td><td>200000</td><td>An estimation of ftp server idle time, in millisec.
  Typically it is 120000 millisec for many ftp servers out there.
  Better be conservative here. Together with ftp.timeout, it is used to
  decide if we need to delete (annihilate) current ftp.client instance and
  force to start another ftp.client instance anew. This is necessary because
  a fetcher thread may not be able to obtain next request from queue in time
  (due to idleness) before our ftp client times out or remote server
  disconnects. Used only when ftp.keep.connection is true (please see below).
  </td>
</tr>
<tr>
<td><a name="ftp.keep.connection">ftp.keep.connection</a></td><td>false</td><td>Whether to keep ftp connection. Useful if crawling same host
  again and again. When set to true, it avoids connection, login and dir list
  parser setup for subsequent urls. If it is set to true, however, you must
  make sure (roughly):
  (1) ftp.timeout is less than ftp.server.timeout
  (2) ftp.timeout is larger than (fetcher.threads.fetch * fetcher.server.delay)
  Otherwise there will be too many "delete client because idled too long"
  messages in thread logs.</td>
</tr>
<tr>
<td><a name="ftp.follow.talk">ftp.follow.talk</a></td><td>false</td><td>Whether to log dialogue between our client and remote
  server. Useful for debugging.</td>
</tr>
<tr>
<td><a name="db.fetch.interval.default">db.fetch.interval.default</a></td><td>2592000</td><td>The default number of seconds between re-fetches of a page (30 days).
  </td>
</tr>
<tr>
<td><a name="db.fetch.interval.max">db.fetch.interval.max</a></td><td>7776000</td><td>The maximum number of seconds between re-fetches of a page
  (90 days). After this period every page in the db will be re-tried, no
  matter what is its status.
  </td>
</tr>
<tr>
<td><a name="db.fetch.schedule.class">db.fetch.schedule.class</a></td><td>org.apache.nutch.crawl.DefaultFetchSchedule</td><td>The implementation of fetch schedule. DefaultFetchSchedule simply
  adds the original fetchInterval to the last fetch time, regardless of
  page changes.</td>
</tr>
<tr>
<td><a name="db.fetch.schedule.adaptive.inc_rate">db.fetch.schedule.adaptive.inc_rate</a></td><td>0.4</td><td>If a page is unmodified, its fetchInterval will be
  increased by this rate. This value should not
  exceed 0.5, otherwise the algorithm becomes unstable.</td>
</tr>
<tr>
<td><a name="db.fetch.schedule.adaptive.dec_rate">db.fetch.schedule.adaptive.dec_rate</a></td><td>0.2</td><td>If a page is modified, its fetchInterval will be
  decreased by this rate. This value should not
  exceed 0.5, otherwise the algorithm becomes unstable.</td>
</tr>
<tr>
<td><a name="db.fetch.schedule.adaptive.min_interval">db.fetch.schedule.adaptive.min_interval</a></td><td>60.0</td><td>Minimum fetchInterval, in seconds.</td>
</tr>
<tr>
<td><a name="db.fetch.schedule.adaptive.max_interval">db.fetch.schedule.adaptive.max_interval</a></td><td>31536000.0</td><td>Maximum fetchInterval, in seconds (365 days).
  NOTE: this is limited by db.fetch.interval.max. Pages with
  fetchInterval larger than db.fetch.interval.max
  will be fetched anyway.</td>
</tr>
<tr>
<td><a name="db.fetch.schedule.adaptive.sync_delta">db.fetch.schedule.adaptive.sync_delta</a></td><td>true</td><td>If true, try to synchronize with the time of page change.
  by shifting the next fetchTime by a fraction (sync_rate) of the difference
  between the last modification time, and the last fetch time.</td>
</tr>
<tr>
<td><a name="db.fetch.schedule.adaptive.sync_delta_rate">db.fetch.schedule.adaptive.sync_delta_rate</a></td><td>0.3</td><td>See sync_delta for description. This value should not
  exceed 0.5, otherwise the algorithm becomes unstable.</td>
</tr>
<tr>
<td><a name="db.update.additions.allowed">db.update.additions.allowed</a></td><td>true</td><td>If true, updatedb will add newly discovered URLs, if false
  only already existing URLs in the CrawlDb will be updated and no new
  URLs will be added.
  </td>
</tr>
<tr>
<td><a name="db.update.max.inlinks">db.update.max.inlinks</a></td><td>50000</td><td>Maximum number of inlinks to take into account when updating 
  a URL score in the crawlDB. Only the best scoring inlinks are kept. 
  </td>
</tr>
<tr>
<td><a name="db.ignore.internal.links">db.ignore.internal.links</a></td><td>true</td><td>If true, when adding new links to a page, links from
  the same host are ignored.  This is an effective way to limit the
  size of the link database, keeping only the highest quality
  links.
  </td>
</tr>
<tr>
<td><a name="db.ignore.external.links">db.ignore.external.links</a></td><td>true</td><td>If true, outlinks leading from a page to external hosts
  will be ignored. This is an effective way to limit the crawl to include
  only initially injected hosts, without creating complex URLFilters.
  </td>
</tr>
<tr>
<td><a name="db.score.injected">db.score.injected</a></td><td>1.0</td><td>The score of new pages added by the injector.
  </td>
</tr>
<tr>
<td><a name="db.score.link.external">db.score.link.external</a></td><td>1.0</td><td>The score factor for new pages added due to a link from
  another host relative to the referencing page's score. Scoring plugins
  may use this value to affect initial scores of external links.
  </td>
</tr>
<tr>
<td><a name="db.score.link.internal">db.score.link.internal</a></td><td>1.0</td><td>The score factor for pages added due to a link from the
  same host, relative to the referencing page's score. Scoring plugins
  may use this value to affect initial scores of internal links.
  </td>
</tr>
<tr>
<td><a name="db.score.count.filtered">db.score.count.filtered</a></td><td>false</td><td>The score value passed to newly discovered pages is
  calculated as a fraction of the original page score divided by the
  number of outlinks. If this option is false, only the outlinks that passed
  URLFilters will count, if it's true then all outlinks will count.
  </td>
</tr>
<tr>
<td><a name="db.max.outlinks.per.page">db.max.outlinks.per.page</a></td><td>-1</td><td>The maximum number of outlinks that we'll process for a page.
  If this value is nonnegative (&gt;=0), at most db.max.outlinks.per.page outlinks
  will be processed for a page; otherwise, all outlinks will be processed.
  </td>
</tr>
<tr>
<td><a name="db.max.anchor.length">db.max.anchor.length</a></td><td>100</td><td>The maximum number of characters permitted in an anchor.
  </td>
</tr>
<tr>
<td><a name="db.parsemeta.to.crawldb">db.parsemeta.to.crawldb</a></td><td></td><td>Comma-separated list of parse metadata keys to transfer to the crawldb (NUTCH-779).
   Assuming for instance that the languageidentifier plugin is enabled, setting the value to 'lang' 
   will copy both the key 'lang' and its value to the corresponding entry in the crawldb.
  </td>
</tr>
<tr>
<td><a name="db.fetch.retry.max">db.fetch.retry.max</a></td><td>3</td><td>The maximum number of times a url that has encountered
  recoverable errors is generated for fetch.</td>
</tr>
<tr>
<td><a name="db.signature.class">db.signature.class</a></td><td>org.apache.nutch.crawl.MD5Signature</td><td>The default implementation of a page signature. Signatures
  created with this implementation will be used for duplicate detection
  and removal.</td>
</tr>
<tr>
<td><a name="db.signature.text_profile.min_token_len">db.signature.text_profile.min_token_len</a></td><td>2</td><td>Minimum token length to be included in the signature.
  </td>
</tr>
<tr>
<td><a name="db.signature.text_profile.quant_rate">db.signature.text_profile.quant_rate</a></td><td>0.01</td><td>Profile frequencies will be rounded down to a multiple of
  QUANT = (int)(QUANT_RATE * maxFreq), where maxFreq is a maximum token
  frequency. If maxFreq &gt; 1 then QUANT will be at least 2, which means that
  for longer texts tokens with frequency 1 will always be discarded.
  </td>
</tr>
<tr>
<td><a name="generate.max.count">generate.max.count</a></td><td>-1</td><td>The maximum number of urls in a single
  fetchlist.  -1 if unlimited. The urls are counted according
  to the value of the parameter generator.count.mode.
  </td>
</tr>
<tr>
<td><a name="generate.max.distance">generate.max.distance</a></td><td>-1</td><td>The maximum distance of an URL that the generator is allowed
  to select for fetch. The distance is the smallest number of nodes (shortest path)
  of an URL from the original injected URL. (Injected URLs have distance 0).
  </td>
</tr>
<tr>
<td><a name="generate.count.mode">generate.count.mode</a></td><td>host</td><td>Determines how the URLs are counted for generator.max.count.
  Default value is 'host' but can be 'domain'. Note that we do not count 
  per IP in the new version of the Generator.
  </td>
</tr>
<tr>
<td><a name="generate.update.crawldb">generate.update.crawldb</a></td><td>false</td><td>For highly-concurrent environments, where several
  generate/fetch/update cycles may overlap, setting this to true ensures
  that generate will create different fetchlists even without intervening
  updatedb-s, at the cost of running an additional job to update CrawlDB.
  If false, running generate twice without intervening
  updatedb will generate identical fetchlists.</td>
</tr>
<tr>
<td><a name="partition.url.mode">partition.url.mode</a></td><td>byHost</td><td>Determines how to partition URLs. Default value is 'byHost', 
  also takes 'byDomain' or 'byIP'. 
  </td>
</tr>
<tr>
<td><a name="crawl.gen.delay">crawl.gen.delay</a></td><td>604800000</td><td>
   This value, expressed in days, defines how long we should keep the lock on records 
   in CrawlDb that were just selected for fetching. If these records are not updated 
   in the meantime, the lock is canceled, i.e. the become eligible for selecting. 
   Default value of this is 7 days.
  </td>
</tr>
<tr>
<td><a name="fetcher.server.delay">fetcher.server.delay</a></td><td>5.0</td><td>The number of seconds the fetcher will delay between 
   successive requests to the same server. Note that this might get
   overriden by a Crawl-Delay from a robots.txt and is used ONLY if 
   fetcher.threads.per.queue is set to 1.
   </td>
</tr>
<tr>
<td><a name="fetcher.server.min.delay">fetcher.server.min.delay</a></td><td>0.0</td><td>The minimum number of seconds the fetcher will delay between 
  successive requests to the same server. This value is applicable ONLY
  if fetcher.threads.per.queue is greater than 1 (i.e. the host blocking
  is turned off).</td>
</tr>
<tr>
<td><a name="fetcher.max.crawl.delay">fetcher.max.crawl.delay</a></td><td>30</td><td>
 If the Crawl-Delay in robots.txt is set to greater than this value (in
 seconds) then the fetcher will skip this page, generating an error report.
 If set to -1 the fetcher will never skip such pages and will wait the
 amount of time retrieved from robots.txt Crawl-Delay, however long that
 might be.
 </td>
</tr>
<tr>
<td><a name="fetcher.threads.fetch">fetcher.threads.fetch</a></td><td>10</td><td>The number of FetcherThreads the fetcher should use.
  This is also determines the maximum number of requests that are
  made at once (each FetcherThread handles one connection). The total
  number of threads running in distributed mode will be the number of
  fetcher threads * number of nodes as fetcher has one map task per node.
  </td>
</tr>
<tr>
<td><a name="fetcher.threads.per.queue">fetcher.threads.per.queue</a></td><td>1</td><td>This number is the maximum number of threads that
    should be allowed to access a queue at one time. Setting it to 
    a value &gt; 1 will cause the Crawl-Delay value from robots.txt to
    be ignored and the value of fetcher.server.min.delay to be used
    as a delay between successive requests to the same server instead 
    of fetcher.server.delay.
   </td>
</tr>
<tr>
<td><a name="fetcher.queue.mode">fetcher.queue.mode</a></td><td>byHost</td><td>Determines how the URLs are placed into queues. 
   Allowed values are 'byHost', 'byDomain' and 'byIP'.
   The value would usually correspond to that of 'partition.url.mode'.
  </td>
</tr>
<tr>
<td><a name="fetcher.queue.use.host.settings">fetcher.queue.use.host.settings</a></td><td>false</td><td>Allows us to optionally enable host specific queue behavior if present.
  </td>
</tr>
<tr>
<td><a name="fetcher.verbose">fetcher.verbose</a></td><td>false</td><td>If true, fetcher will log more verbosely.</td>
</tr>
<tr>
<td><a name="fetcher.parse">fetcher.parse</a></td><td>false</td><td>If true, fetcher will parse content. NOTE: previous releases would
  default to true. Since 2.0 this is set to false as a safer default.</td>
</tr>
<tr>
<td><a name="fetcher.store.content">fetcher.store.content</a></td><td>true</td><td>If true, fetcher will store content.</td>
</tr>
<tr>
<td><a name="fetcher.timelimit.mins">fetcher.timelimit.mins</a></td><td>-1</td><td>This is the number of minutes allocated to the fetching.
  Once this value is reached, any remaining entry from the input URL list is skipped 
  and all active queues are emptied. The default value of -1 deactivates the time limit.
  </td>
</tr>
<tr>
<td><a name="fetcher.max.exceptions.per.queue">fetcher.max.exceptions.per.queue</a></td><td>-1</td><td>The maximum number of protocol-level exceptions (e.g. timeouts) per
  host (or IP) queue. Once this value is reached, any remaining entries from this
  queue are purged, effectively stopping the fetching from this host/IP. The default
  value of -1 deactivates this limit.
  </td>
</tr>
<tr>
<td><a name="fetcher.throughput.threshold.pages">fetcher.throughput.threshold.pages</a></td><td>-1</td><td>The threshold of minimum pages per second. If the fetcher downloads less
  pages per second than the configured threshold, the fetcher stops, preventing slow queue's
  from stalling the throughput. This threshold must be an integer. This can be useful when
  fetcher.timelimit.mins is hard to determine. The default value of -1 disables this check.
  </td>
</tr>
<tr>
<td><a name="fetcher.throughput.threshold.sequence">fetcher.throughput.threshold.sequence</a></td><td>5</td><td>The number of times the fetcher.throughput.threshold is allowed to be exceeded,
  in a row. This setting prevents accidental slow downs from stopping the fetcher.
  </td>
</tr>
<tr>
<td><a name="fetcher.throughput.threshold.check.after">fetcher.throughput.threshold.check.after</a></td><td>5</td><td>The number of minutes after which the throughput check is enabled.</td>
</tr>
<tr>
<td><a name="fetcher.queue.depth.multiplier">fetcher.queue.depth.multiplier</a></td><td>200</td><td>(EXPERT)The fetcher buffers the incoming URLs into queues based on the [host|domain|IP]
  (see param fetcher.queue.mode). The depth of the queue is the number of threads times the value of this parameter.
  A large value requires more memory but can improve the performance of the fetch when the order of the URLS in the fetch list
  is not optimal.
  </td>
</tr>
<tr>
<td><a name="indexingfilter.order">indexingfilter.order</a></td><td></td><td>The order by which index filters are applied.
  If empty, all available index filters (as dictated by properties
  plugin-includes and plugin-excludes above) are loaded and applied in system
  defined order. If not empty, only named filters are loaded and applied
  in given order. For example, if this property has value:
  org.apache.nutch.indexer.basic.BasicIndexingFilter org.apache.nutch.indexer.more.MoreIndexingFilter
  then BasicIndexingFilter is applied first, and MoreIndexingFilter second.
  
  Filter ordering might have impact on result if one filter depends on output of
  another filter.
  </td>
</tr>
<tr>
<td><a name="indexer.score.power">indexer.score.power</a></td><td>0.5</td><td>Used by the OPIC plugin. Determines the power of link analyis scores. 
  Each pages's boost is set to scorescorePower where
  score is its link analysis score and scorePower is the
  value of this parameter.  This is compiled into indexes, so, when
  this is changed, pages must be re-indexed for it to take
  effect.</td>
</tr>
<tr>
<td><a name="indexer.max.title.length">indexer.max.title.length</a></td><td>100</td><td>The maximum number of characters of a title that are indexed. A value of -1 disables this check.
  Used by index-basic.
  </td>
</tr>
<tr>
<td><a name="moreIndexingFilter.indexMimeTypeParts">moreIndexingFilter.indexMimeTypeParts</a></td><td>true</td><td>Determines whether the index-more plugin will split the mime-type
  in sub parts, this requires the type field to be multi valued. Set to true for backward
  compatibility. False will not split the mime-type.
  </td>
</tr>
<tr>
<td><a name="anchorIndexingFilter.deduplicate">anchorIndexingFilter.deduplicate</a></td><td>false</td><td>With this enabled the indexer will case-insensitive deduplicate hanchors
  before indexing. This prevents possible hundreds or thousands of identical anchors for
  a given page to be indexed but will affect the search scoring (i.e. tf=1.0f).
  </td>
</tr>
<tr>
<td><a name="urlnormalizer.order">urlnormalizer.order</a></td><td>org.apache.nutch.net.urlnormalizer.basic.BasicURLNormalizer org.apache.nutch.net.urlnormalizer.regex.RegexURLNormalizer</td><td>Order in which normalizers will run. If any of these isn't
  activated it will be silently skipped. If other normalizers not on the
  list are activated, they will run in random order after the ones
  specified here are run.
  </td>
</tr>
<tr>
<td><a name="urlnormalizer.regex.file">urlnormalizer.regex.file</a></td><td>regex-normalize.xml</td><td>Name of the config file used by the RegexUrlNormalizer class.
  </td>
</tr>
<tr>
<td><a name="urlnormalizer.loop.count">urlnormalizer.loop.count</a></td><td>1</td><td>Optionally loop through normalizers several times, to make
  sure that all transformations have been performed.
  </td>
</tr>
<tr>
<td><a name="mime.type.magic">mime.type.magic</a></td><td>true</td><td>Defines if the mime content type detector uses magic resolution.
  </td>
</tr>
<tr>
<td><a name="plugin.folders">plugin.folders</a></td><td>D:/wksgit/nutch-2.x/build/plugins</td><td>Directories where nutch plugins are located.  Each
  element may be a relative or absolute path.  If absolute, it is used
  as is.  If relative, it is searched for on the classpath.</td>
</tr>
<tr>
<td><a name="plugin.auto-activation">plugin.auto-activation</a></td><td>true</td><td>Defines if some plugins that are not activated regarding
  the plugin.includes and plugin.excludes properties must be automaticaly
  activated if they are needed by some actived plugins.
  </td>
</tr>
<tr>
<td><a name="plugin.includes">plugin.includes</a></td><td>protocol-http|index-more|urlfilter-regex|parse-(html|tika)|index-(basic|anchor)|urlnormalizer-(pass|regex|basic)|scoring-opic</td><td>Regular expression naming plugin directory names to
  include.  Any plugin not matching this expression is excluded.
  In any case you need at least include the nutch-extensionpoints plugin. By
  default Nutch includes crawling just HTML and plain text via HTTP,
  and basic indexing and search plugins. In order to use HTTPS please enable 
  protocol-httpclient, but be aware of possible intermittent problems with the 
  underlying commons-httpclient library.
  </td>
</tr>
<tr>
<td><a name="plugin.excludes">plugin.excludes</a></td><td></td><td>Regular expression naming plugin directory names to exclude.  
  </td>
</tr>
<tr>
<td><a name="parse.plugin.file">parse.plugin.file</a></td><td>parse-plugins.xml</td><td>The name of the file that defines the associations between
  content-types and parsers.</td>
</tr>
<tr>
<td><a name="parser.character.encoding.default">parser.character.encoding.default</a></td><td>windows-1252</td><td>The character encoding to fall back to when no other information
  is available</td>
</tr>
<tr>
<td><a name="encodingdetector.charset.min.confidence">encodingdetector.charset.min.confidence</a></td><td>-1</td><td>A integer between 0-100 indicating minimum confidence value
  for charset auto-detection. Any negative value disables auto-detection.
  </td>
</tr>
<tr>
<td><a name="parser.caching.forbidden.policy">parser.caching.forbidden.policy</a></td><td>content</td><td>If a site (or a page) requests through its robot metatags
  that it should not be shown as cached content, apply this policy. Currently
  three keywords are recognized: "none" ignores any "noarchive" directives.
  "content" doesn't show the content, but shows summaries (snippets).
  "all" doesn't show either content or summaries.</td>
</tr>
<tr>
<td><a name="parser.html.impl">parser.html.impl</a></td><td>neko</td><td>HTML Parser implementation. Currently the following keywords
  are recognized: "neko" uses NekoHTML, "tagsoup" uses TagSoup.
  </td>
</tr>
<tr>
<td><a name="parser.html.form.use_action">parser.html.form.use_action</a></td><td>false</td><td>If true, HTML parser will collect URLs from form action
  attributes. This may lead to undesirable behavior (submitting empty
  forms during next fetch cycle). If false, form action attribute will
  be ignored.</td>
</tr>
<tr>
<td><a name="parser.html.outlinks.ignore_tags">parser.html.outlinks.ignore_tags</a></td><td></td><td>Comma separated list of HTML tags, from which outlinks 
  shouldn't be extracted. Nutch takes links from: a, area, form, frame, 
  iframe, script, link, img. If you add any of those tags here, it
  won't be taken. Default is empty list. Probably reasonable value
  for most people would be "img,script,link".</td>
</tr>
<tr>
<td><a name="htmlparsefilter.order">htmlparsefilter.order</a></td><td></td><td>The order by which HTMLParse filters are applied.
  If empty, all available HTMLParse filters (as dictated by properties
  plugin-includes and plugin-excludes above) are loaded and applied in system
  defined order. If not empty, only named filters are loaded and applied
  in given order.
  HTMLParse filter ordering MAY have an impact
  on end result, as some filters could rely on the metadata generated by a previous filter.
  </td>
</tr>
<tr>
<td><a name="parser.timeout">parser.timeout</a></td><td>36000</td><td>Timeout in seconds for the parsing of a document, otherwise treats it as an exception and 
  moves on the the following documents. This parameter is applied to any Parser implementation. 
  Set to -1 to deactivate, bearing in mind that this could cause
  the parsing to crash because of a very long or corrupted document.
  </td>
</tr>
<tr>
<td><a name="parser.skip.truncated">parser.skip.truncated</a></td><td>true</td><td>Boolean value for whether we should skip parsing for truncated documents. By default this 
  property is activated due to extremely high levels of CPU which parsing can sometimes take.  
  </td>
</tr>
<tr>
<td><a name="urlfilter.tld.length">urlfilter.tld.length</a></td><td></td><td>Maximum Character length of top-level-domain</td>
</tr>
<tr>
<td><a name="urlfilter.domain.file">urlfilter.domain.file</a></td><td>domain-urlfilter.txt</td><td>Name of file on CLASSPATH containing either top level domains or
  hostnames used by urlfilter-domain (DomainURLFilter) plugin.</td>
</tr>
<tr>
<td><a name="urlfilter.regex.file">urlfilter.regex.file</a></td><td>regex-urlfilter.txt</td><td>Name of file on CLASSPATH containing regular expressions
  used by urlfilter-regex (RegexURLFilter) plugin.</td>
</tr>
<tr>
<td><a name="urlfilter.automaton.file">urlfilter.automaton.file</a></td><td>automaton-urlfilter.txt</td><td>Name of file on CLASSPATH containing regular expressions
  used by urlfilter-automaton (AutomatonURLFilter) plugin.</td>
</tr>
<tr>
<td><a name="urlfilter.prefix.file">urlfilter.prefix.file</a></td><td>prefix-urlfilter.txt</td><td>Name of file on CLASSPATH containing url prefixes
  used by urlfilter-prefix (PrefixURLFilter) plugin.</td>
</tr>
<tr>
<td><a name="urlfilter.suffix.file">urlfilter.suffix.file</a></td><td>suffix-urlfilter.txt</td><td>Name of file on CLASSPATH containing url suffixes
  used by urlfilter-suffix (SuffixURLFilter) plugin.</td>
</tr>
<tr>
<td><a name="urlfilter.order">urlfilter.order</a></td><td></td><td>The order by which url filters are applied.
  If empty, all available url filters (as dictated by properties
  plugin-includes and plugin-excludes above) are loaded and applied in system
  defined order. If not empty, only named filters are loaded and applied
  in given order. For example, if this property has value:
  org.apache.nutch.urlfilter.regex.RegexURLFilter org.apache.nutch.urlfilter.prefix.PrefixURLFilter
  then RegexURLFilter is applied first, and PrefixURLFilter second.
  Since all filters are AND'ed, filter ordering does not have impact
  on end result, but it may have performance implication, depending
  on relative expensiveness of filters.
  </td>
</tr>
<tr>
<td><a name="scoring.filter.order">scoring.filter.order</a></td><td></td><td>The order in which scoring filters are applied.
  This may be left empty (in which case all available scoring
  filters will be applied in the order defined in plugin-includes
  and plugin-excludes), or a space separated list of implementation
  classes.
  </td>
</tr>
<tr>
<td><a name="lang.ngram.min.length">lang.ngram.min.length</a></td><td>1</td><td> The minimum size of ngrams to uses to identify
  language (must be between 1 and lang.ngram.max.length).
  The larger is the range between lang.ngram.min.length and
  lang.ngram.max.length, the better is the identification, but
  the slowest it is.
  </td>
</tr>
<tr>
<td><a name="lang.ngram.max.length">lang.ngram.max.length</a></td><td>4</td><td> The maximum size of ngrams to uses to identify
  language (must be between lang.ngram.min.length and 4).
  The larger is the range between lang.ngram.min.length and
  lang.ngram.max.length, the better is the identification, but
  the slowest it is.
  </td>
</tr>
<tr>
<td><a name="lang.analyze.max.length">lang.analyze.max.length</a></td><td>2048</td><td> The maximum bytes of data to uses to indentify
  the language (0 means full content analysis).
  The larger is this value, the better is the analysis, but the
  slowest it is.
  </td>
</tr>
<tr>
<td><a name="lang.extraction.policy">lang.extraction.policy</a></td><td>detect,identify</td><td>This determines when the plugin uses detection and
  statistical identification mechanisms. The order in which the
  detect and identify are written will determine the extraction
  policy. Default case (detect,identify)  means the plugin will
  first try to extract language info from page headers and metadata,
  if this is not successful it will try using tika language
  identification. Possible values are:
    detect
    identify
    detect,identify
    identify,detect
  </td>
</tr>
<tr>
<td><a name="lang.identification.only.certain">lang.identification.only.certain</a></td><td>false</td><td>If set to true with lang.extraction.policy containing identify,
  the language code returned by Tika will be assigned to the document ONLY
  if it is deemed certain by Tika.
  </td>
</tr>
<tr>
<td><a name="index.metadata">index.metadata</a></td><td>description,keywords</td><td>
  Comma-separated list of keys to be taken from the metadata to generate fields.
  Can be used e.g. for 'description' or 'keywords' provided that these values are generated
  by a parser (see parse-metatags plugin), and property 'metatags.names'.
  </td>
</tr>
<tr>
<td><a name="metatags.names">metatags.names</a></td><td>*</td><td>Names of the metatags to extract, separated by ','.
  Use '*' to extract all metatags. Prefixes the names with 'meta_' in
  the parse-metadata. For instance, to index description and keywords,
  you need to activate the plugins parse-metadata and index-metadata
  and set the value of the properties 'metatags.names' and
  'index.metadata' to 'description,keywords'.
  </td>
</tr>
<tr>
<td><a name="hadoop.job.history.user.location">hadoop.job.history.user.location</a></td><td>${hadoop.log.dir}/history/user</td><td>Hadoop 0.17.x comes with a default setting to create
     user logs inside the output path of the job. This breaks some
     Hadoop classes, which expect the output to contain only
     part-XXXXX files. This setting changes the output to a
     subdirectory of the regular log directory.
  </td>
</tr>
<tr>
<td><a name="solr.mapping.file">solr.mapping.file</a></td><td>solrindex-mapping.xml</td><td>
  Defines the name of the file that will be used in the mapping of internal
  nutch field names to solr index fields as specified in the target Solr schema.
  </td>
</tr>
<tr>
<td><a name="solr.commit.size">solr.commit.size</a></td><td>250</td><td>
  Defines the number of documents to send to Solr in a single update batch.
  Decrease when handling very large documents to prevent Nutch from running
  out of memory. NOTE: It does not explicitly trigger a server side commit.
  </td>
</tr>
<tr>
<td><a name="solr.commit.index">solr.commit.index</a></td><td>true</td><td>
  When closing the indexer, trigger a commit to the Solr server. 
  </td>
</tr>
<tr>
<td><a name="solr.auth">solr.auth</a></td><td>false</td><td>
  Whether to enable HTTP basic authentication for communicating with Solr.
  Use the solr.auth.username and solr.auth.password properties to configure
  your credentials.
  </td>
</tr>
<tr>
<td><a name="elastic.host">elastic.host</a></td><td></td><td>The hostname to send documents to using TransportClient.
  Either host and port must be defined or cluster.
  </td>
</tr>
<tr>
<td><a name="elastic.port">elastic.port</a></td><td>9300</td><td>
  The port to connect to using TransportClient.
  </td>
</tr>
<tr>
<td><a name="elastic.cluster">elastic.cluster</a></td><td></td><td>The cluster name to discover. Either host and potr must
  be defined or cluster.
  </td>
</tr>
<tr>
<td><a name="elastic.index">elastic.index</a></td><td>nutch</td><td>
  The name of the elasticsearch index. Will normally be autocreated if it
  doesn't exist.
  </td>
</tr>
<tr>
<td><a name="elastic.max.bulk.docs">elastic.max.bulk.docs</a></td><td>250</td><td>
  The number of docs in the batch that will trigger a flush to
  elasticsearch.
  </td>
</tr>
<tr>
<td><a name="elastic.max.bulk.size">elastic.max.bulk.size</a></td><td>2500500</td><td>
  The total length of all indexed text in a batch that will trigger a
  flush to elasticsearch, by checking after every document for excess 
  of this amount.
  </td>
</tr>
<tr>
<td><a name="storage.data.store.class">storage.data.store.class</a></td><td>org.apache.gora.memory.store.MemStore</td><td>The Gora DataStore class for storing and retrieving data.
   Currently the following stores are available:
  
  org.apache.gora.sql.store.SqlStore 
    Default store. A DataStore implementation for RDBMS with a SQL interface.
    SqlStore uses JDBC drivers to communicate with the DB. As explained in 
    ivy.xml, currently &gt;= gora-core 0.3 is not backwards compatable with 
    SqlStore.
  
  org.apache.gora.cassandra.store.CassandraStore
    Gora class for storing data in Apache Cassandra.
  
  org.apache.gora.hbase.store.HBaseStore
    Gora class for storing data in Apache HBase.
  
  org.apache.gora.accumulo.store.AccumuloStore
    Gora class for storing data in Apache Accumulo.
  
  org.apache.gora.avro.store.AvroStore
    Gora class for storing data in Apache Avro.
    
  org.apache.gora.avro.store.DataFileAvroStore
    Gora class for storing data in Apache Avro. DataFileAvroStore is 
    a file based store which uses Avro's DataFile{Writer,Reader}'s as a backend.
    This datastore supports mapreduce.
    
  org.apache.gora.memory.store.MemStore
    Gora class for storing data in a Memory based implementation for tests.
  </td>
</tr>
<tr>
<td><a name="storage.schema.webpage">storage.schema.webpage</a></td><td>webpage</td><td>This value holds the schema name used for Nutch web db.
  Note that Nutch ignores the value in the gora mapping files, and uses
  this as the webpage schema name.
  </td>
</tr>
<tr>
<td><a name="storage.schema.host">storage.schema.host</a></td><td>host</td><td>This value holds the schema name used for Nutch host db.
  Note that Nutch ignores the value in the gora mapping files, and uses
  this as the host schema name.
  </td>
</tr>
<tr>
<td><a name="storage.crawl.id">storage.crawl.id</a></td><td>tokopedia_id</td><td>This value helps differentiate between the datasets that
  the jobs in the crawl cycle generate and operate on. The value will
  be input to all the jobs which then will use it as a prefix when
  accessing to the schemas. The default configuration uses no id to prefix
  the schemas. The value could also be given as a command line argument
  to each job.
  </td>
</tr>
<tr>
<td><a name="gora.buffer.read.limit">gora.buffer.read.limit</a></td><td>10000</td><td>The maximum number of buffered Records we wish to
  read in one batch. @see org.apache.gora.mapreduce.GoraRecordReader
  </td>
</tr>
<tr>
<td><a name="gora.buffer.write.limit">gora.buffer.write.limit</a></td><td>10000</td><td>Configures (for the Hadoop record writer) the maximum number of 
  buffered Records we wish to regularly flush to the Gora datastore. 
  @see org.apache.gora.mapreduce.GoraRecordWriter.
  </td>
</tr>
</table>
</body>
</html>
